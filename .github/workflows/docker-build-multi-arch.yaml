# .github/workflows/docker-build-multiarch.yml
name: Reusable Multi-Arch Docker Build

on:
  workflow_call:
    inputs:
      image-name:
        description: 'Docker image name (e.g., username/image or ghcr.io/org/image)'
        required: true
        type: string

      context:
        description: 'Build context path'
        required: false
        type: string
        default: '.'

      dockerfile:
        description: 'Path to Dockerfile'
        required: false
        type: string
        default: './Dockerfile'

      platforms:
        description: 'Comma-separated list of platforms (amd64,arm64)'
        required: false
        type: string
        default: 'amd64,arm64'

      registry:
        description: 'Container registry (dockerhub, ghcr, or ecr)'
        required: false
        type: string
        default: 'dockerhub'

      build-args:
        description: 'Build arguments (multiline string)'
        required: false
        type: string
        default: ''

      tags:
        description: 'Additional custom tags (newline separated)'
        required: false
        type: string
        default: ''

      target:
        description: 'Dockerfile target stage to build'
        required: false
        type: string
        default: ''

      cache-type:
        description: 'Cache type (gha, registry, or disabled)'
        required: false
        type: string
        default: 'registry'

      aws-region:
        description: 'AWS region for ECR (required if registry is ecr)'
        required: false
        type: string
        default: 'us-east-1'

      ref:
        description: 'Git ref to checkout (branch, tag, or SHA). Defaults to the ref that triggered the workflow'
        required: false
        type: string
        default: ''

      repository:
        description: 'Repository to checkout (owner/repo). Defaults to the repository that triggered the workflow'
        required: false
        type: string
        default: ''

    secrets:
      registry-user:
        description: 'Registry username or AWS Access Key ID'
        required: false

      registry-token:
        description: 'Registry password/token or AWS Secret Access Key'
        required: false

      repository-token:
        description: 'Repository token for github checkout'
        required: false

      build-secrets:
        description: 'Build secrets values (multiline string, format: id=value)'
        required: false

    outputs:
      image-tag:
        description: 'The primary image tag that was built'
        value: ${{ jobs.merge.outputs.image-tag }}

      digest:
        description: 'The image digest'
        value: ${{ jobs.merge.outputs.digest }}

      tag:
        description: 'The primary tag (sha-<short_sha> or combined tag if build args provided)'
        value: ${{ jobs.merge.outputs.tag }}

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}

    steps:
      - name: Create build matrix
        id: set-matrix
        run: |
          platforms="${{ inputs.platforms }}"
          IFS=',' read -ra PLATFORMS <<< "$platforms"

          matrix_json="["
          for platform in "${PLATFORMS[@]}"; do
            platform=$(echo "$platform" | xargs)  # trim whitespace

            case "$platform" in
              amd64)
                runner="ubuntu-latest"
                ;;
              arm64)
                runner="linux-arm64"
                ;;
              *)
                echo "Unsupported platform: $platform"
                exit 1
                ;;
            esac

            matrix_json+="{\"arch\":\"$platform\",\"runner\":\"$runner\"},"
          done

          # Remove trailing comma and close array
          matrix_json="${matrix_json%,}]"

          echo "matrix=$matrix_json" >> $GITHUB_OUTPUT
          echo "Generated matrix: $matrix_json"

  build:
    needs: prepare
    strategy:
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.matrix) }}

    runs-on: ${{ matrix.runner }}

    outputs:
      build-hash: ${{ steps.build-hash.outputs.hash }}
      combined-tag: ${{ steps.build-hash.outputs.combined }}
      digest-key: ${{ steps.build-hash.outputs.digest-key }}
      metadata-json: ${{ steps.meta.outputs.json }}
      metadata-version: ${{ steps.meta.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repository || github.repository }}
          ref: ${{ inputs.ref }}
          token: ${{ secrets.repository-token || github.token }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        if: inputs.registry == 'ecr'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.registry-user }}
          aws-secret-access-key: ${{ secrets.registry-token }}
          aws-region: ${{ inputs.aws-region }}

      - name: Login to Amazon ECR
        if: inputs.registry == 'ecr'
        uses: aws-actions/amazon-ecr-login@v2

      - name: Login to Docker Hub
        if: inputs.registry == 'dockerhub'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.registry-user }}
          password: ${{ secrets.registry-token }}

      - name: Login to GitHub Container Registry
        if: inputs.registry == 'ghcr'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.registry-user || github.actor }}
          password: ${{ secrets.registry-token || secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ inputs.image-name }}
          context: 'git'
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=ref,event=pr
            type=ref,event=branch
            type=sha,priority=1000
            ${{ inputs.tags }}

      - name: Generate build hash
        id: build-hash
        run: |
          # Use version from metadata (sha-{short_sha} from checked-out repo)
          VERSION="${{ steps.meta.outputs.version }}"

          # Create a deterministic hash from build args and secrets
          BUILD_ARGS="${{ inputs.build-args }}"
          BUILD_SECRETS="${{ secrets.build-secrets }}"

          if [[ -n "$BUILD_ARGS" || -n "$BUILD_SECRETS" ]]; then
            # Sort and normalize the build args to ensure consistency
            SORTED_ARGS=""
            if [[ -n "$BUILD_ARGS" ]]; then
              SORTED_ARGS=$(echo "$BUILD_ARGS" | tr '\n' ' ' | tr -s ' ' | xargs -n1 | sort | tr '\n' ' ')
            fi

            # Sort and normalize the secrets (values included in hash for differentiation)
            SORTED_SECRETS=""
            if [[ -n "$BUILD_SECRETS" ]]; then
              SORTED_SECRETS=$(echo "$BUILD_SECRETS" | tr '\n' ' ' | tr -s ' ' | xargs -n1 | sort | tr '\n' ' ')
            fi

            # Generate short hash (8 chars)
            HASH=$(echo -n "${SORTED_ARGS}${SORTED_SECRETS}" | sha256sum | cut -c1-8)
            echo "hash=$HASH" >> $GITHUB_OUTPUT

            COMBINED_TAG="${VERSION}.build-${HASH}"
          else
            COMBINED_TAG="${VERSION}"
          fi

          echo "combined=$COMBINED_TAG" >> $GITHUB_OUTPUT

          # Generate unique digest key from image name + combined tag (for artifact naming)
          DIGEST_KEY=$(echo -n "${{ inputs.image-name }}:${COMBINED_TAG}" | sha256sum | cut -c1-16)
          echo "digest-key=$DIGEST_KEY" >> $GITHUB_OUTPUT

          echo "Combined tag: $COMBINED_TAG"
          echo "Digest key: $DIGEST_KEY"

      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.dockerfile }}
          target: ${{ inputs.target }}
          platforms: linux/${{ matrix.arch }}
          build-args: ${{ inputs.build-args }}
          secrets: ${{ secrets.build-secrets }}
          outputs: type=image,name=${{ inputs.image-name }},push-by-digest=true,name-canonical=true,push=true
          cache-from: ${{ inputs.cache-type != 'disabled' && format('type=registry,ref={0}:buildcache-{1}', inputs.image-name, matrix.arch) || '' }}
          cache-to: ${{ inputs.cache-type != 'disabled' && format('type=registry,ref={0}:buildcache-{1},mode=max', inputs.image-name, matrix.arch) || '' }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Export digest
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ steps.build-hash.outputs.digest-key }}-${{ matrix.arch }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge:
    runs-on: ubuntu-latest
    needs: [build]
    outputs:
      image-tag: ${{ steps.summary.outputs.image-tag }}
      digest: ${{ steps.inspect.outputs.digest }}
      tag: ${{ steps.summary.outputs.tag }}

    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-${{ needs.build.outputs.digest-key }}-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        if: inputs.registry == 'ecr'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.registry-user }}
          aws-secret-access-key: ${{ secrets.registry-token }}
          aws-region: ${{ inputs.aws-region }}

      - name: Login to Amazon ECR
        if: inputs.registry == 'ecr'
        uses: aws-actions/amazon-ecr-login@v2

      - name: Login to Docker Hub
        if: inputs.registry == 'dockerhub'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.registry-user }}
          password: ${{ secrets.registry-token }}

      - name: Login to GitHub Container Registry
        if: inputs.registry == 'ghcr'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.registry-user || github.actor }}
          password: ${{ secrets.registry-token || secrets.GITHUB_TOKEN }}

      - name: Create manifest list and push
        id: meta
        working-directory: /tmp/digests
        env:
          DOCKER_METADATA_OUTPUT_JSON: ${{ needs.build.outputs.metadata-json }}
        run: |
          # Set version output and re-export metadata for subsequent steps
          echo "version=${{ needs.build.outputs.metadata-version }}" >> $GITHUB_OUTPUT
          echo "DOCKER_METADATA_OUTPUT_JSON=$DOCKER_METADATA_OUTPUT_JSON" >> $GITHUB_ENV

          # Build tag list from metadata and add combined tag
          TAG_ARGS=$(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON")
          TAG_ARGS="$TAG_ARGS -t ${{ inputs.image-name }}:${{ needs.build.outputs.combined-tag }}"

          docker buildx imagetools create $TAG_ARGS \
            $(printf '${{ inputs.image-name }}@sha256:%s ' *)

      - name: Inspect image
        id: inspect
        run: |
          digest=$(docker buildx imagetools inspect ${{ inputs.image-name }}:${{ steps.meta.outputs.version }} --format '{{json .Manifest.Digest}}' | tr -d '"')
          echo "digest=$digest" >> $GITHUB_OUTPUT
          docker buildx imagetools inspect ${{ inputs.image-name }}:${{ steps.meta.outputs.version }}

      - name: Write job summary
        id: summary
        run: |
          IMAGE_TAG="${{ inputs.image-name }}:${{ needs.build.outputs.combined-tag }}"
          # Build tags list with combined tag, formatted as markdown
          TAGS_LIST=$(echo "$DOCKER_METADATA_OUTPUT_JSON" | jq -r \
            --arg combined "$IMAGE_TAG" \
            '.tags + [$combined] | unique | map("- `" + . + "`") | join("\n")')

          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "tag=${{ needs.build.outputs.combined-tag }}" >> $GITHUB_OUTPUT

          {
            cat <<EOF
          ## Docker Build Summary

          ### Image
          \`${{ inputs.image-name }}\`

          ### Tags

          ${TAGS_LIST}

          ### Digest
          \`${{ steps.inspect.outputs.digest }}\`

          ### Platforms
          \`${{ inputs.platforms }}\`
          EOF
          } >> $GITHUB_STEP_SUMMARY
